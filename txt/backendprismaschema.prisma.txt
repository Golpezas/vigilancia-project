// prisma/schema.prisma - Fase 2: Multi-servicio con puntos personalizados
// Mejores prácticas 2026: Relación many-to-many explícita (tabla intermedia), auditoría automática, índices optimizados
// Optimizaciones: Agregado @@index([uuid]) para queries idempotentes rápidas (batch sync)
//               Índice compuesto para anti-duplicados (vigiladorId + uuid)
//               Constraint en Punto.nombre @unique ya existe, ok
// Depuración: Agrego createdBy opcional para audit futuro (e.g., UserId)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"  
}

model Servicio {
  id        String   @id @default(uuid())
  nombre    String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  vigiladores Vigilador[]
  puntos      ServicioPunto[]
  registros   Registro[]

  // ── Relación bidireccional con User ────────────────────────────────────────
  users User[] @relation("UserServicio")

  @@map("servicio")
}

model Vigilador {
  id          String   @id @default(uuid())
  nombre      String
  legajo      Int      @unique
  ultimoPunto Int      @default(0)
  rondaActiva Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  servicioId  String
  servicio    Servicio @relation(fields: [servicioId], references: [id])

  registros Registro[]

  @@map("vigilador")
}

model Punto {
  id        Int      @id @default(autoincrement())
  nombre    String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  registros Registro[]
  servicios ServicioPunto[] // Relación opuesta

  @@map("punto")
}

model ServicioPunto {
  servicioId String
  puntoId    Int

  servicio Servicio @relation(fields: [servicioId], references: [id])
  punto    Punto    @relation(fields: [puntoId], references: [id])

  @@id([servicioId, puntoId]) // Clave compuesta
  @@map("servicio_punto")
}

model Registro {
  id              String   @id @default(uuid())
  vigiladorId     String
  puntoId         Int
  servicioId      String
  timestamp       DateTime
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  geolocalizacion String?
  novedades       String?
  uuid            String?  @unique // Idempotencia clave
  createdBy       String?  // Opcional: Para audit (UserId futuro)

  vigilador Vigilador @relation(fields: [vigiladorId], references: [id])
  punto     Punto     @relation(fields: [puntoId], references: [id])
  servicio  Servicio  @relation(fields: [servicioId], references: [id])

  @@index([vigiladorId, timestamp])
  @@index([vigiladorId, createdAt])
  @@index([servicioId])
  @@index([uuid]) // Nuevo: Perf para idempotencia en batch
  @@index([vigiladorId, uuid]) // Nuevo: Anti-duplicados por vigilador
  @@map("registro")
}

model User {
  id         String   @id @default(uuid())
  email      String   @unique
  password   String
  role       Role     @default(CLIENT)
  servicioId String?  // FK opcional
  servicio   Servicio? @relation("UserServicio", fields: [servicioId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("user")
}

enum Role {
  ADMIN
  CLIENT
}